Wiki Algorithm:
===============

set up initial node velocities to (0,0)
 set up initial node positions randomly // make sure no 2 nodes are in exactly the same position
 loop
     total_kinetic_energy := 0 // running sum of total kinetic energy over all particles
     for each node
         net-force := (0, 0) // running sum of total force on this particular node
         
         for each other node
             net-force := net-force + Coulomb_repulsion( this_node, other_node )
         next node
         
         for each spring connected to this node
             net-force := net-force + Hooke_attraction( this_node, spring )
         next spring
         
         // without damping, it moves forever
         this_node.velocity := (this_node.velocity + timestep * net-force) * damping
         this_node.position := this_node.position + timestep * this_node.velocity
         total_kinetic_energy := total_kinetic_energy + this_node.mass * (this_node.velocity)^2
     next node
 until total_kinetic_energy is less than some small number  // the simulation has stopped moving


An implementation on in AS3
---------------------------

package
{
   import flash.display.Sprite;
   import flash.geom.Point;
 
   public class Vertex extends Sprite
   {
      // speed of vertex
      public var velocity:Point = new Point(); 
      // force twards other vertices in the network
      public var net_force:Point = new Point();
      public var isDragged:Boolean = false;  // I can drag the vertex

      public function Vertex():void
      {
         // I draw a ring into the middle
         with(graphics)
         {
            beginFill(0xFF005E);
            drawEllipse(-12, -12, 24, 24);
            endFill();
         }

      }

   }
}

create the graph

   // set of vertices
   vertices = new Vector.< Vertex >(n, true);
   // set of edges in symetric incidence matrix
   edges = new Vector. < Vector.< Boolean >>(n, true);
   for(i=0; i < n; i++) edges[i] = new Vector.< Boolean >(n, true);
   while(e > 0) // add some edges
   {
      var a:int = Math.floor(Math.random()*n);
      var b:int = Math.floor(Math.random()*n);
      if(a==b || edges[a][b])continue;
      edges[a][b] = true;
      edges[b][a] = true;
      e--;
   }
   // creating vertices
   for(i=0; i < n; i++)
   {
      var v:Vertex = new Vertex();
      v.x = 200+Math.random()*300;
      v.y = 100+Math.random()*200;
      vertices[i] = v;
      addChild(v);
      v.addEventListener(MouseEvent.MOUSE_DOWN, drag);
      v.addEventListener(MouseEvent.MOUSE_UP, sdrag);
   }


Actually layout the graph
=========================

function onEF(e:Event):void
{
   for(i=0; i < n; i++) // loop through vertices
   {
      var v:Vertex = vertices[i];
      var u:Vertex;
      v.net_force.x = v.net_force.y = 0;
      for(j=0; j < n; j++) // loop through other vertices
      {
         if(i==j)continue;
         u = vertices[j];

		 /* PETER: I assume this is the Columb_repulsion */
         // squared distance between "u" and "v" in 2D space
         var rsq:Number = ((v.x-u.x)*(v.x-u.x)+(v.y-u.y)*(v.y-u.y));
         // counting the repulsion between two vertices 
         v.net_force.x += 200 * (v.x-u.x) /rsq;
         v.net_force.y += 200 * (v.y-u.y) /rsq;
      }
      for(j=0; j < n; j++) // loop through edges
      {
         if(!edges[i][j])continue;
         u = vertices[j];

		 /* PETER: Again I assume the Hooke Attraction */
         // countin the attraction
         v.net_force.x += 0.06*(u.x - v.x);
         v.net_force.y += 0.06*(u.y - v.y);
      }
      // counting the velocity (with damping 0.85)
      v.velocity.x = (v.velocity.x + v.net_force.x)*0.85; 
      v.velocity.y = (v.velocity.y + v.net_force.y)*0.85; 
   }
   for(i=0; i < n; i++) // set new positions
   {
      v = vertices[i];
      if(v.isDragged){ v.x = mouseX; v.y = mouseY; }
      else { v.x += v.velocity.x; v.y += v.velocity.y; }
   }
   // drawing edges
   graphics.clear();
   graphics.lineStyle(3, 0x333333);
   for(i=0; i < n; i++)
   {
      for(j=0; j < n; j++)
      {
         if(!edges[i][j]) continue;
         graphics.moveTo(vertices[i].x, vertices[i].y);
         graphics.lineTo(vertices[j].x, vertices[j].y);
      }
   }
}

