API Index:
----------

(Top Level Index)

1.2. Splangdangle Index
 1.2.1 API Functions
  1.2.1.1 SI_Initialise
  1.2.1.1 SI_DoSomeWork
  1.2.1.1 SI_DoMoreWork
  1.2.1.1 SI_Finalise
 1.2.2 API Types
  ...
  ...
 1.2.3 API ...

follows the requirement of the index that it is being displayed in.

(in field index)
 Follows the requirement of the index request.





Index problems:
---------------

 1 -> 1.1 -> 1.2 -> 1.3
      |
	  +-> 2.1
	      |
		  +-> 3.1

This needs to happen for each level.

So, each level needs sub-items list and next item in level.
It it has an owner then it can do a tree walk.

Each item must have a owner, next, child.

 [item:1] -> [item:1.1] -> [item:1.1.1]
             [item:1.2] -> [item:1.2.1]
 
 [item:2] -> [item:2.1]

So, three links are required. next_level, parent, child.

When going down a level current_item->child = new_item
new_item->parent = current_item

When adding an item at the same level, it inherits the parent,
and the child is null, and the next pointer is set on the
current item.


document index levels
---------------------

index=numbered

1 Level One
   1.1 Level two
    1.1.1 Level three

index=plain

Level One
 Level Two
  Level Three

index=numbered,reference=true,line=true

1 Level One...........................................1.1
 

Table of Contents

 [model:/document?index,numbered,reference,line]

List

 [model:/document?index,level,numbered]
 [model:/default/api?index,numbered]

for the applications:

They belong to the group?

or are applications high level?

If the application is high level (like the group) there can be a default application and all sections
can then attach to this.

This will allow for applications to accept generic functions that are shared across applications and
can be include in the Documentation.

So, Applications should work like functions, except that multiple definitions are not allowed.

Vim scripts (syntax):

	                 e
					 |
					 |
					 |
   s-----------------b-------------------s
                     |
					 |
					 |
					 e                  (d)


^
| 
y
 x->

u = sx or ex
v = ey or sy
p = ex or sx
q = sy or ey
b = (u,v)

dx = (u < x < p) . y == v

	if handled for plus minus, should be no problem.

	if ((sx < x < bx) or (sx > x > bx)) and (by == y)
	if ((by < y < ey) or (ey < x < by)) and (bx == x)

	
					 e
					 |
					 |
	s----------------b

	if ( s < x < bx) and (by == y)
	if ( e > x > by) and (bx == x)
 
	bx = sx
	by = ey


	to go down, swap s and e around.

	so, 


