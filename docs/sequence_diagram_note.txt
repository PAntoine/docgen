
 How messages connect:

 [node] -------------> [node]

 send                  wait_for


 Different types of addressing.
 
 Send to a specific timeline. That is [server] -> [device] this seems like the simplest model.
 So the @to atom rules here. Also, means that all messages are simply collected in the timeline
 that they originated in.

 Also, we need broadcasts. These are a little more complicated as they must belong to the group
 and be searched when the messages are being connected.

 a broadcast is defined as:

 send: message_name
 to: *

 waitfor: message_name

 after: message_name

 to and from are used to capture message from specific timelines. But are not required as the
 named message will always be captured.

[server]               [media_source]      [media_sink]
   |-------request---------->|                   |
   |                         |-----play--------->|
   |                         |<----ok------------|
   |<-------ack--------------|


------ server ------

/**
 * @send: request
 * @to: media_source
 */

/**
 * @waitfor: ack
 */

------- media source ------

/**
 * @call: play
 * @waitfor: request
 */

/**
 * @send: ack
 * @waitfor: ok
 * @from: media_sink
 */

------- media sink -------

/**
 * @send: ok
 * @responds: play
 */


@tag. This is only needed if you send the same message more than once, but you want to create
a different wait for that message. You will need to set the tag for that message so that the
linker can differentiate the two messages.

Note:

If a call is made to a function, then the function/activation can be pulled into the current
timeline. This is unless the function has a specific timeline of its own. This means that
functions/activations must inherit the calling message. That means that it can send messages
as responses, i.e. use the responds atom to allow the message to respond to a message sent
to the function.


=====================================

Problem:

If the same message is sent from a timeline.

[timeline1]         [timeline2]
     |------mess1-------->|
	 |------mess1-------->|

Timeline 2 needs 2 waits (@waitfor: mess1).

If timeline2 does not have this then it fails. The messages are fixedup in order. The waits and the
messages are then tied together. The messages will need be sorted by order of afters and responds
so that the fixup can be done in simple order.

So each timeline will have a list of message instances pointing away from it, and a list of waits
for messages incomming.

So each timeline will handle it. So for each timeline (in sequential order) see if there is a matching
message.

So processing works as follows:

- process the inputs and add all the nodes: 
Create a list of messages and waits for all the timelines and
attach the nodes. Each message is new. The name is only used for fixup. Create the messages as UNATTACHED
as that flag can be removed when the message is attached to a wait. The message needs to know what the
node it belongs to is.

If any of the nodes have an after attached then they should be delt with. The message
in the current timeline should be searched for. The @after or @reponds can set the GHOST flag if the
message instance does not exist at creation. But it should exist by fixup time. Fixup could be done on
the fly but the functions will change the order of the messages so the inter-timeline fixup must be 
done as a separate stage.

The order of searching for messages is in reverse order. This means that the nearest message will bind with
the after.

The @responds and @response atoms will return to the calling timeline. The @response can only be used within
a function. It will attach all the messages from within the function to the calling timeline.

- Fixup the functions:

As functions are not allowed to use @after or @responds outside of the current function these means that
they are in the correct place already and do not need ordering.

- Fixup the timelines:

This stage will attach the inter-timeline messages. It for each timeline walk down the list of nodes and
find the matching messages to the waiting waits.

If they don't match then the link fails. Simples.

How do you call a function on a different timeline. Easy you just call it. Add it to the timeline. It should
not be dependent on any other messages so it should wash down the line.

[a]  [b]  [c]
 |--->|    |
 |----+--->|
 |--->|    |
 |<---+----|
 |--->|    |

Does [a] ever want to call [b].function()? Yes.

So, Nodes have order. @after or @responds. The line between timelines is from the node.  So Nodes have 
transitions too. 

So inter-timeline transitions are either calls or messages. Timelines send from themselves to another timeline.

transition:
type = {function,message}
to = {timeline}

So the messages are fixed up in order. The messages are lined up.

----------------------------------------

So, all messages are transitions.
Transitions are in a list.
The afters only effect one transition.
The afters are fixed up in the transition.

-------------------


to process a message node:

a. mark it a in progress.
b. if it has a send call progress on that send.
c. if it has reponses to the timeline that sent the message handle the progress the responses.
d. return to the calling node.


message needs to have a pointer to the node that creates/sends it. (it needs to be added to create_message or just after it is created).

so, the current node is set to the target node of the message.
The node is processed, i.e. 

walk down the list of sends.
walk down the list of receives.

for all the nodes that are part of a function, or has a dependency, make that node the current_node, and process that node.

if the current_message has a next massage make that current, go again.
else goto the next node.


for all t = timeline
 for all cn = timeline.node
  working_node = cn

  if (!working_node.procesed)
   while (working_node != null)
	for all m = working_node.sent_messages
	 handle_message(m)
	 working_node = working_node.sent_messages.target_node
	
	for all m = working_node.recieved_messages
	 handle_message(m)
	 
	working_node.processed = true

	if (working_node.dependancy)
	 working_node = working_node.next
	else
	 working_node = null
   loop while

--------------------- MORE NOTES -----------------------

cn = current_node
while cn != null
  while (cm != null)
    if cn.sent_message != null
      cm = cn.sent_message
      handle_message(cm)
      cn = cn.sent_message.receiver
    else
      if cm.next != null
        cm = cm.next
      else if cn.receiver != null
        handle_message(cn.receiver.message)
      end if
    end if
  end while

  cn = cn.waitfor.sender
end while

without recursion cannot walk chains, as a call stack will need to be built.

problem:

[a] ------> [b]
            [b']
            [b'']

[b] has the pointer with the return to [a]. b' will need to know where [b] is. So all dependencies will need to 
know what node they are dependant on, or the caller will need to maintain a stack.

Maybe that is a good thing, as the checking of messages can be verified. If the end of chain has the receives message
and a flag to notify that it is the end of the chain. Then the return can happen from here.

This will work???

So this will now look like this:

[a] ------> [b]
 |          [b']
 | <------- [b'']
[a']    

It does mean the function and after code will need to handle this. Also, it solves another problem, I could add a 
return flag for the node so it knows it needs to return (that might actually be a rubbish idea).

It means that the walking prototype from above now looks like (adding in timeline code):

level = 0
tl = sequence_diagram.timeline
while tl != null
	cn = tl.node
	cn.level = 0
	cn.toggle = !cn.toggle

	while cn != null
		cm = cn.sent_message
		
		if level > cn.level 
			fail

		while (cm != null)
			if cm.processed != cn.toggle
				cm.processed = cn.toggle
				handle_message(cm)
				increment level
				cn = cn.sent_message.receiver
				cn.toggle = cn.toggle
			else
				cm = cm.next
			end if
		end while

		if (cn.dependency)
			cn = cn.next
			cn.toggle = !cn.toggle
			cn.level = level
		else
			decrement level
			cn = cn.waitfor.message.sender
		end if
	end while

	tl = tl.next
end while

As the list element in a dependency list will have the same sender as the entry node. Also, as no message will ever
be sent to this node that is valid. It does mean for multiple dependency chains the last node cannot have a dependency.

Either will have to add a dummy node or not allow for this. I think the dummy node will be the better result.

The end node, that has the response will have to have the FLAG_DEPENDENCY_END to stop direct attachments being added 
in when doing the sequence connections.

The level check should stop the sub messages or nodes calling back to a super message.

[a] [b] [c]
 |---|   |    0 -> 1  - on send
 |   |---|    1 -> 2  - on send
 |   |   |
 |   |---|    1 <- 2  - on cm = null
 |---|   |    0 <- 1  - on cm = null
 |   |   |
 |---|   |    0 -> 1  - on send
 |   |---|    1 -> 2  - on send



So if C calls a level > a.level failure! (note: c could be either side of [a] as [b]->[c]->[a] is valid. It is just the
logical level in the call chain that matters.

by using a toggle it will make sure that the correct message is started. If the toggle matches the message then it has
been processed this visit.

-------------------------

The other problem is that all nodes that have a waitfor should be skipped.

The other problem is that messages might have to be marked as completed. So when you return to a node it walks its own
list of messages looking for a message that has not been satisfied and action that message.

-------------------------

Next problem:
The walker does not know what message it responds to. So it really needs to duplicate the whole of the message chain that
it references if the wait has already been satisfied. It will need to do this for all sends and all the duplicates for the
sends will have to be done as well.

[a] <===== [b]
           [b] <======== [c]
           [b] <====================== [d]

When [c] uses [b]
when [d] uses [b] it duplicates it, and it then duplicates [a]

so it gets:

[a] <----- [b]
           [b]  <------- [c]

           [b'] <--------------------- [d]
[a'] <---- [b']

All is good in the world.

There is a looping problem. As this could be never ending as if a -> b -> c -> a. So a copy algorithm the same as the graph
walker will have to be used. It means that the graph walker function will have to generalised so it can be used for both
functions. But only one flag is required so that the item that has been visited in the list is used. It might have to be
a toggle so at the start of the search it sets the flag so when it walks down it does not have to reset the value.

It means that the message chains can be removed and the walker can be simplified as it no longer has to
worry about message chains as all messages are one to one.

So a lot of the code that was put in to handle many->one and one->many lists are a bit rubbish and not required. :(

-------------------------

walk the list.

goto the message that it should. 

create a new local node, then copy the message and all of it the dependent messages.
add the new list to the end of the dependency list.
walk the new list and to the same thing again.


the walk could look like this.

aaaaaaaaaaaaaaaaaaaaaaaaa
 |               |
 bbbbbbbb        eeeeeeeee
    |   |             |  |
	ccc dddd          ff ggggg

copy b then do c, then do d. The back up the tree to e then do f and then g.

This should work fine.

  [a] -----> [b]
   |`
  [a'] -----> [b']

sent message is a duplicate so need to insert a node into the timeline. 

aaffffffffffffffff
 |               |
 bbbbddddd       ggggggiiii
    |    |            |   |
	ccc  eeee         hh  jjjjjj

The only problem is that level one is the only one that has to fit within a sequence.
All the rest do not. They can or the system cannot be rendered. So a simple walk and
copy will do. Problem with this is the references are not easy to copy.

Don't think this will work.

So,

	b------>e
	|       |
	c->e    h->j

so do all a. 
Create a up-list of things that need doing for a. i.e. b&e.
Do that list. when b ends (dependancy break the link) carry on with e.
Create an up-list for b->e parse that.

No loop detection.
Copies cannot be done on a timeline in the list of timelines visited in this section.
Sectioning the timelines may be a bit of a problem.

ban all for now.

This should work.

So, if a send then add the message to the uplink.
When finished the copy make the current node the uplink and carry one.
The uplink is a temporary timeline. And can add the copy of the receiver node.
walk it and create a new uplink every time.

-------------------------------------

Sequence Diagrams in dot:

Something like this:

digraph SO {
	{
		rank = same
		a b c d
	}

	a -> a1 -> a2
	b -> b1 -> b2 -> b3 -> b4
	c -> c1
	d -> d1 -> d2 -> d3
}

This will draw each rank top to bottom and the ranks across the page.

This should be quite easy to do.

Obviously it can also be written,
b -> b1
b1 -> b2
b2 -> b3 


----- even more crappy inconstant notes -----------

function calls are defined like this now:

[function]   <---- messages in
[node] <--->
[node] <--->
[function_end] no messages


we can walk the lists including messages by using the function_end pointer in the function_end to act
as a return statement. As all functions can only be entered onces this is correct.

So as we need to be able to copy the sent message, if the message points to a function then you can copy
the whole function chain using the function_end as the return point.

[function]
[node] -------------> [function]
                      [node] ---------------> [function]
					  [node] ---------------> [function_end]
[function_end]	----> [function_end]

The return should be to node->next as this makes the walking easier. Also the state and end of the walk
should set the function_end pointer to NULL. This works for both the copy and the display code later.

Problems:

If the code is just walking the list then no problem, but the list needs to have the new chain also follow
the list. So it will need to also have a walk done. In fact it should just mirror the original walk. The
same node and walk functions should be used. 

The node->next cannot be used as this would make this fail as there is no next pointer. So the walk would
have to return to the node that it branched from. 

NOTE: a end marker could be used and it would make an insert point, but I think that would make life a 
little more complicated than t should be.

Actually the insert walk will need an end marker or it will not know from whence it came. The end marker
would have to have the sender node and then after the original has returned the next node would be the
inserts end marker and it would know where the call came from.

so:

if target.node.function = true
copy target.node -> new_node
add new_node to insert
create end.node
end.node.return = new_node
insert = new_node
current = target.node
walk down target.node
if target.node.function_end = true
temp = insert.return
insert.return = temp
insert = temp

So, that the function_end pointer in the end node of the insert chain points to the insert point that
it left. But, as all functions start blocks need the end block to be set up it can do this when it
leaves the level as it will know both these values as this point.

The current walk bit is easy. It goes until end then does a return. As the start of the function knows
where the end it can set this.

[c]->[f]
[i]->[n]
     [f]->[f1]
	 [i]->[n]
	 [ ]<-[  ]
[i]<-[ ] 

So need to do a simple two-step to allow for the walk to keep the insert and the walk in step.

So the simple walking functions, need to set function and the current node. Also it needs to be able
to tell you when the walk comes to an end. So....

next_tree_node()

This function will walk the tree using the sends as the links down the tree. It will walk up and down the tree.

[n]
 |
[n]--s->[n]
[ ]<----[ ]
[n]--s->[f]
[n]<-r--[n]
[n]---->[ ]


So ignoring the above diagram then the next_tree_node will need to walk either the response,send or both as
modes. 

This function needs to be written as a standalone without any other code to confuse it.

three functions:

bool next_send_node(current,&next_current,&function);
bool next_recieve_node(current,&next_current,&function);
bool next_tree_node(current,&next_current,&function);

for the send node:

while node does not equal null,
	if node sends a message goto the receiving node.
	if node has a dependency or node does not have a caller, goto the next node.
	if node has a caller return to the caller.





