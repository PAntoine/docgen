                        DOCUMENT GENERATOR

						        by

					      Peter Antoine
					  2011 (c) Peter Antoine

version: 1.0
date:    5th Nov 2011

1. Statement Of Purpose

The doc_gen application is designed to create system documents from comments in the source code.
It is especially designed to generate Sequence and State Machine diagrams.

1.1 Reasoning.
As with all document generators from code the main reason is to aid the keeping of documentation and
code in sync. This is designed to allow for the extracted information to be able to be formatted in
other ways and to have the documentation to be defined by a definition file so the documentation can
be properly formatted. It is also good to be able to code actual documents and have the app stitch 
the two together in a sensible way.

1.2. Responsibilities.

1.2.1 Locate all the special markers in the code tree and add them to a DB.
1.2.2 Build the connected graphs for the different items.
1.2.3 collate the document mark-up with the generated data.
1.2.4 generate the resulting mark-up.
1.2.5 for all steps above validate the data and return warning/errors.

1.3. Specific Exclusions.

1.3.1 Do not produce the resulting docs (only mark-up).
1.3.2 Any form of pagination or layout that is for the final rendering tool.

2. System Operation.

2.1. Functional Operation

To allow for build-tree conditional compilation. (In file conditionals will be ignored) the system will
work in the same way as the C style compilers. That is a doc_compile function will run on all the source
code file and produce data files that hold all the extracted information, after while a compile step will
run that will then produce the final diagrams and then link in all the external data files and produce
the final mark-up.

The "compiler" will create the output files in the same way that compilers do and have the equivalent of
the "-o" (output) flag. There should be no requirement for the the compiler to include any other file or
configuration file as it will just create an "object" file of all the data items that it finds.

The "linker" will take all the "object" files and validate then and then generate the mark-up. The compiler
will take the list of created "object" files plus the support files to create the final mark-up. Also, the 
"linker" may need to accept a configuration file for producing the final output.

2.1.1 Peters Document Source Compiler (pdsc)

This function will create the document object file (.dof) that is used by the document linker to to produce
the final mark-up. The function will simply take in a source file and produce an object file as specified.
This function can fail if an error is detected in the mark-up of the document.

The objects in a source file can either be grouped explicitly by name. Though the name can be a macro that
is passed into the compile function. This allow for multi items the be created and have meaningful and non
contrived names.

2.1.2 Peter Document Linker (pdl)

This function will produce the final mark-up for the document. It will take a list of files. I will spit
out a marked up function.

2.1.3 Peter's Document Proccesor (pdp)

This umtility will take in the linked document from the pdl and proccess it with the other .md documents
to produce the final doc for output. This is what produces the final document. This is the function handles
the markup (Markdown).

3. Operation Rational

The use of a compiler and a linker basically has the following reasons:

3.1. Map Reduce
As will all compilers the compile and link stages can be broken up and done in parallel if the build system
will allow.

3.2 Build System Friendly
As the compile function can be placed in a makefile in the same way that the source compiler function can, it
means that an almost duplicate rule can be used to generate the document object file.

3.3 Partial Build
Again as the make system can be used to select which source files have changed and which needs to be rebuilt
this means that rebuilding the documents are the same as rebuilding the source and will speed up the creation
of the documents.

4. Design.

4.1. Mark-up overview

The mark-up style will follow the current conventions that are used in JavaDoc, Doxygen and others. Mostly 
because they are familiar to most programmers and a lot of editors will recognise most of the syntax.

So all mark-up fields will be defined within a C style comment with two leading **'s.

i.e

/**
 * This is a comment block.
 */

The basic atom are have the following format:
  @<atom_type>: -- atom value --

The atom value can be one of the following types:

  name           format/description
  -------------  ------------------------------------
  name           <atom_group>.<name>
  literal        numeric or string literal
  trigger        Logical statement for stating when the item is actioned.
  text line      single line of text ended at the end of line.
  text string    block text string ending with the <atom_type> or end of the comment.

Also, the system will allow for macros $(macro_name) to replace all or part of the strings. This is
mostly to allow for group type names to be tailored by the build. This will allow for the same file
to be used by several build and be part of different system or sub systems.

To reduce the amount cruft that the editor has to add to the source files, the @file atom block can
be defined at the top of the source file. This block defines the global groups for the all the atom groups.
You also can define the sub-groups i.e. the timeline name.

4.2 Structure

All the graphs/diagrams are defined by nodes. All nodes need to have a type and a name. Also depending
on what type of node it is then they may have other dependencies. For example that a state_machine node
will have a @next: as all state machine nodes (with the exception of sm_end) have a next state.

All the required atoms MUST be in the same comment block. If they are not present or cannot be inferred
then the compiler will raise a warning and/or fail.

The types of atom are TYPE, ACTION, ORDER, PAYLOAD and GROUPING. 

4.2.1 TYPE
Each node is a comment and must have one of the atoms that define the TYPE of node within the comment
block. So for a state machine node the comment block should have the @state atom within. With the
sequence diagram the @message atom must be defined.

4.2.2 ACTION
Each node should have an ACTION atom that will tell the compiler what the next node to transverse to is.
Without an action atom then node will be assumed to be a terminating node.

4.2.3 ORDER
If a node is defined in several parts then the actions will be defined in the order that they are compiled.
Unless a ORDER atom is found. I.e. if you require a message to be sent before another message that is not
dependent on the previous atom then use @after: {name}, with {name} being the name of the previous atom.

4.2.4 PAYLOAD
The payload atom defines the content of the action. It may contain what the logical action would be i.e.
the content of the message. Also, it may define other attributes of the action, i.e. when or if the action
would occur. Examples of these atoms would be @condition, @if or @parameter.

4.2.5 GROUPING
Some of the atoms may need to be grouped together as a logical grouping. i.e. for the sequence diagram they
have an "activation" that is a group of logically connected messages. So the grouping atoms are the atoms
that are used to create these things. for the example given the group atom would be @activation. This would
allow the mark-up to create a group and give it the attribute "activation". Groups are not required but
the system to draw graphs. The grouping should come from the connections created by the actions.

The group atoms do not override or interfere with the atom_group as this is used to control the connection
of the graphs and is used to sub-divide the graphs. The GROUP names should not have an atom_group as this
would remove the point of them as logical grouping on the diagrams and not as structural atoms.

4.3.6 STRUCTURE
These atoms are for aiding the structure of the documentation. They are there for helping the compiler 
organise the state of the atoms.

4.3 Source data files format

The extra files should be based on Mark-Down and any output produced by the system can be referenced by
using the Markdown reference escape [...] with the URI of model:/<atom_name>, i,e,

[model:/group_name/state_machine]
[model:/group_name/timeline]

the default diagrams can be references via:

[model:/<group_name>/state_machine]
[model:/<group_name>/timeline]

To allow for markup to be able to set references then [<some text>](atom name) will allow for inline text.

which will cause the main state machine diagram to be inserted at that point in the diagram. All items that
have been produced by the system can be referenced more than once.

All docs that are included are built as separate blobs and then referenced. If the final target is to be
a single object then that will be done by the renderer.

NOTE: it is intended for the system to be extended to handle other data styles and tables and these will
be added as there own URLs.

The source files can specify sub-diagrams by creating diagrams based on the groups. So that diagrams can be
defined as follows:

<diagram_name> = include <atom_group>

(Not the definition language may get extended).

The resulting diagram may then be used as follows: [model:/<diagram_name>]

4.4 ATOM descriptions (by data type)

The current diagrams/data types supported are the Sequence Diagram and the State Machine.

4.4.1 Sequence Diagram ATOMS

4.4.1.1 Structure of a sequence diagram

Sequence diagrams are described in the following way:

[start] ----> [state_1] -----> [state_2] -----> [state_3] ----> [finish]
   |             |               ^                 |
   |             |               |                 |
   |             v               |                 |
   +-------> [state_4] ----------+                 |
                 ^                                 |
                 +---------------------------------+

(As an example)

This diagram has no triggers or conditions for the state transitions that can be specified for each of the
transitions.

4.4.1.2 Definitions of the allowed atoms

@state: {state_name}
 This defines the name of the state. It is also the type atom.
 This atom does not have to be unique if it occurs more than once in a tree then they are seen as the same state.
 The states MUST not have the same @next as this cannot be built in the tree.#

@next: {state_name}
 This defines the next transition of the state machine.
 This atom must point to a state this has been defined within the group of states.

@condition: {state}
 This atom defines the condition that causes the transition to occur. This is mostly documentary and can be text.

@trigger: <trigger_name>
 This atom describes FORMALLY when the trigger occurs. This can be used to generate a formal state machine. The
 trigger name will be created and checks can be made to see if the triggers are sent and received. This atom will
 be displayed as a comment and also can be used to prove that the state machine is correct.

 Note 1: that the trigger does not need to belong to group that the state machine is in. As it can be used to link
 state machines in the system together. If the {location} states internal then the trigger will need to be generated
 with the same group.

 Also, triggers can work across the diagram types and also can just be fired. This will help stitch the whole system 
 together.
 
 Note 2: @trigger can also be stand alone if the trigger for a state machine is generate outside of the state machine.

@triggers:
This sends the trigger for the @trigger to receive. It can send a trigger across state machines or sequence diagrams.

4.4.1.3 Validity of States
 - All states must have the following atoms: @state and @next.
 - The state pointed to by @next must exist and be defined within the same group.
 - If a state has a @trigger the @triggers atom must be called at least once. (does not need to be within the group).
 - A @trigger and @condition atom cannot exist within the same state.
 - If the atom_group is used then this will divide the state machine.
 - The state "finish" is implied and does not need to be defined. But, if it is defined it cannot have a @next atom.
 - @state is allowed to to have a group, if it does not it defaults the global group.
 - all other atoms are not allowed to specify the group (except @state, @trigger and @triggers).

4.4.2 Sequence Diagram

4.4.2.1 Structure of a Sequence Diagram

[timeline_1]       [timeline_2]       [timeline_3]       [timeline_4]
     |-------mess01----->|                  |                  |     
     |                   |-mess02(a,b,c,d)->|                  |     
     |<---------------mess04----------------|                  |     
     |                   |-----mess05----->[ ]                 |     
     |                   |                 [ ]----mess06------>|     
     |                   |                 [ ]----mess07------>|     
     |                   |                 [ ]<---mess08-------|     
     |                   |<----mess09------[ ]                 |     
     |<------mess10------|                  |                  |     
     |<----mess11-[cona]-|                  |                  |     
     |<----mess12-[conb]-|                  |                  |     

(as an example)

mess01: Simple message sent from timeline1 to timeline2
mess02: message sent from timeline_2 to timeline_3 with parameters.
mess04: Simple message sent from timeline_3 to timeline_1.
mess05: Message sent from timeline_2 to timeline_3 and received within an activation.
mess06: sent from within an activation.
mess07: send after mess6 within an activation.
mess08: waitfor mess7 and sent to an activation.
mess09: waitfor mess8 then sent to timeline_2.
mess10: waitfor mess9 and sent to timeline_1.
mess11: sent on condition cona from timeline_2 to timeline_1.
mess12: sent on condition conb from timeline_2 to timeline_1.

These are the currently supported messages and conditionals supported.

4.4.2.2 Definitions of the allowed atoms.

@send: {name}
 Send the named message.

@call: {name}
 Call the function as part of the sequence.

@to: {life_line}
 Defines the receiving timeline.
 {limitations????}

@condition: {condition string}
 This is the textual condition that the message is sent on.

@trigger: <trigger_name>
 Same as defined for the state machine.

@waitfor: {message_name}
 This states that the message must be after the named message has arrived.

@after: {message_name}
 This states that the message will be sent after named message.
 The named message MUST be sent from the same timeline.

@timeline: {name}
 The name of the timeline that the message is to be sent from.

@responds: {message_name}
 This the same as to, except that the response goes to the
 timeline that sent the original message message_name.

@repeats: {repeats string}
 This atom states that the specific message repeats for the
 condition given (this is text string).

@activation: {activation_name}
 This is a called activation that groups messages together and can be called from other

@broadcast: {message_name}
 This is a message that is sent to all timelines. Each instance of a broadcast can only
 be matched once per timeline.

4.4.2.3 Validity Of Sequences
 4.4.2.3.1 All Sequences must have either @call or @send.
 4.4.2.3.2 All Sequences must have a @to or @responds.
 4.4.2.3.3 Only one @waitfor atom can be specified per node.
 4.4.2.3.4 If @condition is specified the @trigger can not be. (and vis versa).
 4.4.2.3.5 If @trigger is specified then one @triggers must be specified (does not have to be within a sequence diagram).
 4.4.2.3.6 The message pointed to by @responds must have been sent to the current timeline.
 4.4.2.3.7 The @after clause can be specified on a message or an activation, from the same timeline.
 4.4.2.3.8 All messages must what a corresponding @waitsfor.

4.4.3 Global file format ATOMS

4.4.3.1 Structure file header format

There is no structure for this.

4.4.3.2 Valid atoms for the file state.

@file:
This defines the atom group that defines the defaults for the file. Any atom that is found in this group will
be the defaults for the file.

@author:
This atom defines the author of the file.

@group:
This atom MUST only exist in the @file atom. It defines the default group for the all the atom groups in the file.
It means that all other defined groups will default to this group.

@timeline:
This atom when in the file group will define the default timeline for all other sequence diagram atoms.

4.4.3.3 Validity of File formats

All states that are listed in 4.4.3.3 are valid and can be given in the @file atom block. They can only be one
given once and should be at the top of the source file.

4.4.4 API ATOMS
The following atoms are are used to define API's that are present within a source file. These should be used to
define the API calls. It is assumed that functions that do not have the @api atom in the block preceding the
definition of the function will not be part of the API.

4.4.4.1 Structure API

The API will find functions. The structure of the definition of a API function should be:

/**
 * comment block with the api definition in.
 */
<variable amount of white space>
function_prototype parameters

These will be defined by the language type.

4.4.4.2 Valid atoms for the API

@api:		{function_name}
The name of the function as it should appear in the api.

@brief:		{ brief description of the fuction}
The brief description of the function.

@action:	{action description}
A text section that defines the action of the api. This is a multiline block of text that ends at the next
atom or the end of the comment block. Also, this can be added to the main body of the function if another
action block is found.

@group:		{group_name}
The group that the atom belongs to.

@parameter:	<name>	<description>	One of the parameters, If any.
Definition of one of the parameters for the function.

@returns:	{value} {reason}
Definition of one of the return types for the function.

@ignore:	This stops all collection of data from the header block.
This tag can be used as a nice way of ending a multi-line comment.  It essentially ends the comment block as
far as the processor is concerned.

4.4.4.3 Validity of API Atoms.
 4.4.4.3.1 One one @api will be allowed in a comment block.
 4.4.4.3.2 Only one @brief will be accept in a block.
 4.4.4.3.3 @action must follow a @api or be in an @api block.
 4.4.4.3.4 @action will be attached to any previous @action found for the the @api.
 4.4.4.3.5 @api must be before the function.
 4.4.4.3.6 all atoms found within the function following the @api will be attached to the @api.

4.4.5 Data Type ATOMS

The following is to describe the data type definition atoms.

4.4.5.1 Structure Data Type ATOMS
No inherent type for data types as they will produce a text table within the target document.

4.4.5.2 Valid atoms for the Data Types
@group:	{group_name}
The group that the type belongs to.

@type: {type_name}
This defines the type block and tells the processor that the type that follows is to be decoded.

@defines: {define_name}
This denotes that the following defines are part of the API. All the defines that follow this bloc will be part
of the define block. 

@end_define
This atom is an optional atom the follows a @define so the parser can stop looking for defines to add.

@record: {record_name}
This atom defines a block that defines a record.

@field:	{type}	{name} {description}
The above defines a field in the record.

4.4.5.3 Validity of Data Type Atoms.
 4.4.4.5.1 One one data definition per block
 4.4.4.5.2 The @type and @defines must come before a data type or a #define respectively.
 4.4.4.5.3 @end_define must only be used after a @define and after at least one #define.

4.4.6 Application ATOMS
The Usage atoms are there to be able to describe the usage of an application. This will allow for the man pages for
the application to be generated from the code.

4.4.6.1 Structure of Application ATOMS
The usage atoms are based on the ones required to produce man pages. As a man page can have any structure that you care for
the atoms are quite free form to allow for the user to structure the manual pages as they see fit. If the application has
a command line the synopsis for the command line can be generated from the @option atoms. Also, if the function has internal
commands these can be formatted from the @command atom.

4.4.6.2 Valid atoms for Application
@application:	{name of the application}
This is the name of the application as will displayed in the manual pages.

@group: {group name}
The group that the atom belongs to.

@option: {option description}
This is the option. It is a single word in a free format. I.e. -p or --path or path, it is up to the application type to
define this.

@required:	{yes}|{no}
If this is within a option block defines if the option is required on the command line. If the option is within an named
option, it defines if the option is required within the option group.

@multiple:	{yes}|{no}
This atom states that the atom can accept multiple values.

@command:	{name}	{brief description}
This is a command that goes in to the command list.

@section: {section name}
This defines the section. All the text that follows the atom will be part of the section.

@subsection:	{sub-section name}
As with the @section this defines the subsection and the text of the section will follow the atom.

@synopsis: {name}	{list of options}
This is the standard synopsis of the application flags and usage.

@desc: {multi-line description of the application}
The basic description of the application.

@value:	 {definition of the values that are supported}
This defines the values that are allowed for the option.

4.4.6.3 Validity of Application ATOMS
 4.4.6.3.1 There must be a least 1 @application atom within the source file.
 4.4.6.3.2 All other atoms will bind to the last @application atom.
 4.4.6.3.3 @value must follow a @option and will bind with the nearest one in the same file.
 4.4.6.3.4 @required and @multiple must follow a @option and will bind with the nearest one in the same file.
 4.4.6.3.5 If there is a @section or @subsection is found then it is added to the end of the section. If this
           happens across source files then the order that they are added is not defined and they should be
		   written to handle this.

4.5 Intermediate object file format.

A simple file format that has the basic information.

magic no = 0x70647363  (pdsc)
version  = 0xMMmm      (Major/Minor)
date     = 0xddmmyymmsspp (1 byte padding to keep the size word aligned)
size     = number of records in the file
name     = [length]<file-name as passed into the compiler>	(length is an unsigned int)
<records>

There are three types of records: group, name, string.

The records all have the same format.

[type:ATOM:GROUP:<string>]

For the group, obviously ATOM and GROUP will always be zero, and the group name will be the string.
The others all fields are valid.

Also, the groups are referenced in order that they are found in the file. 

So the layout of the record is:

byte 0 = type
byte 1 = atom
word 2 = group/function
word 4 = name_size
byte 6 - name_size bytes = name (this is not null terminated)

As function are groupless and just exist, they can share the same field.

4.6 Linking Rules

4.6.1 Global Structure.

The structure of the document will have a list of groups, each group is allowed to hold one of each 
of the supported diagrams (at the moment a state_machine and a sequence_diagram).

Also, the document will also have a list of triggers as this work outside of the diagrams. The triggers
are like all other elements in the system, if a trigger is referenced before it is defined then it will
be created as a ghost trigger and when it is defined this flag will be removed.

There is also an un-named default group that all items that do not have a specific group name belong to.
This group has the same requirements as all groups that only one diagram of any type can be used.

4.6.2 Linking the State_Machine

Each state is simply a list of transitions. As each of the atoms in the state machine are added then
the new transition will be added to the state that it belongs to. If it points to a state that does
not exist that state will be created as a "ghost" state and the connection made. When the state is
defined at a later state then the ghost flag will be removed.

As the states are added any transitions that are identical will be flagged as errors.

Also, transitions will be within the same state machine an this can be checked at this point.

Any triggers that are references will be looked up in the trigger list, if it already exists then it
will be referenced. Any trigger that is waited on, and is not defined will be created as a ghost 
trigger and when a definition is created then the ghost flag will be removed.

If the state_machine must be formal then all the states with transitions must have either a @waitfor
or a @condition specified.

4.6.3 Linking the sequence diagrams

The structure of the sequence diagram is a series of linked items. There are three element types to
the sequence diagram, the message/function call, then timeline and the activity.

4.6.3.1 Messages

Messages are transitions between timelines. Messages belong to the timeline that they are sent from. The
receiving timeline must have a @waitfor for each message sent. This means that all messages sent are
handled by some code. All messages are unique. If a message of the same name is sent it needs to be matched
each time, and the nearest match will be used.

Broadcast is a speciality message that is sent to all timelines that exist. They do not need to be matched
except once. They can only be matched once in each timeline.

4.6.3.2 Timelines

Timelines is a sequential ordering of messages. The time line is made up of message or activity connections.
These connections reference specific messages or an activity. The @after clause and the order
that the order that the messages are found define the timeline.

4.6.3.3 Nodes

Timelines are made up of nodes. The nodes are the points on the timeline where the messages are sent and
the messages are received. The nodes are allowed to generate triggers. These are not generated by the
messages as with the state transitions. All messages originate and arrive at a node, tags are attached to
nodes and the nodes are generated and cannot be references directly.

A @waitfor node will be generated for any message that does not already have a node. If the @waitfor has
other nodes or things dependant on them and there is an unsatisfied message then all the nodes for that
dependency will also be duplicated.

4.6.3.4 Activations

These are collections of messages. The activations (if in a C/C++ file) will populate the parameters for
the call. Any messages that are define within the start/end markers (in C/C++ these are '{' and '}'
respectively). These are referenced counted so that the matching pair are used to bound the activation.
The messages that are found in the activation are attached in the order that they are found.

The activation is similar to the activation as the messages within the activation will be a link of nodes.
except the activation will be integrated within the timeline that calls it.

As the activation cannot be linked until all the files have been read and the places that require activations
have been found. The activations are to be integrated into the timelines that call them, so all the messages
that are used by the activation must be looked up then. So the activation can only list the nodes as lookups.
It needs to track the activation names and trigger names for looking up later.

Also, nodes within a message cannot have a sequence outside the activation. It is also assumed that messages
within a activation are in order and should not have a @after node. (This may change).

Activations can only be called within the current timeline. They can be called within a @waitfor block and
if they are then the message that @waitfor is waiting for is used within any @responds block that does not
have a specific @waitfor.

Activations cannot have any atoms that define which timeline they live in. It has to position independent 
so can be included and fixed up at any time. 

4.6.3.5 Node Fix-ups

The timelines are fixed up in the order of the first timeline to the last found in the sequence diagram. The
nodes are fixed starting with the first node found. Each timeline has control while it is in a sequence. I.e.
when a node the has a dependency or is the last in the chain of dependencies is being processed. Functions
members are also dependencies.

4.7 Final Output

The other input files (*.pmd) will be read in and scanned for the [model:/ ] url and anyplace that this is
found on the next new line then the diagram will be inserted. The default for the diagrams are text ascii
art representations. Also the output will also be as *.md files. The output will follow the standard 
MarkDown rules. 

The diagrams will be output as group_name_diagram.md for each of the diagrams found in the source tree.

Extension information can be added to the nodes in the sequence trees, these extensions can add links to
the actual source code lines that defines the atom states and the messages and transitions for the message
states.

4.7.1 API Output Structure

The API output is levelled in it's structure. *finish this later*

  [model:/<group>/api/function/<item>/<part>]
  [model:/<group>/api/define/<item>/<part>]
  [model:/<group>/api/type/<item>/<part>]

if only the api is specified then all the items within the API are exported. If one of the sections are
specified then all the items within that section is listed. If the item is specified then only the item
is specified. Also, the sub-part of the item can also be spefied.

i.e. If you have an function in the api.

/**
 * @api
 * @group test_1
 * @desc sdfggdfgdfgdfgdsg
 *       gfdfggdfgfdgdfgdfgd
 * @author p.asdsfdsf
 * @params gdggfgdgdfgdf
 * @parans fddfsdf
 * @returns
 */

Each of the sections can be listed separately.

[model:/test_1/api/function/] will list all.
[model:/test_1/api/function/name] will only list the nmae.
[model:/test_1/api/function/prototype] will display the prototype.

Also,
need to add the types and constants.

The special group thing for the constants:

@constants

and @end_constants

4.7.2 Format of the outputs

The format of the data groups can be changed. The way this is done is by passing parameters to the model url.
The parameters are passed in the REST style as this will stay with the theme of using URLs as parts.

The three groups of format parameters are, layout, format, style.

The formats are added to the end of the model: url, in the following format:

[model:/test_1/api/function?format=text&stype=paged]
[model:/test_1/api/start_function/name?format=text&stype=inline]

4.7.2.1 FORMAT

This group will define what format the item is output in. Not all items support all of the main formats support
all of the known output formats, but if it is not supported then it will fall back to the default for the
output type.

i.e. 
format=dot
format=text

The first will produce the output for the item in dot format, and the second will produce the output in a text
format. As specified above this is a suggestion to the output function for the format that the user requests.

4.7.2.2 LAYOUT

This tells the output function what layout that the style allows. This allows for, say a state machine to be
laid out either as a table or a graph (obviously each of the styles will have a layout format of its own).

i.e.
layout=table
layout=graph

4.7.2.3 STYLE

This is a comma separated list of styles that are to apply to the item. The common styles are things like 'paged'
that will allow for a multi-item listing to be paginated (if supported). Also, 'inline' for single line items
so that the item does not have any newlines added at the start or the finish.

