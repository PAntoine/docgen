Structural Atoms
================

The atoms and timelines specified within a file can be grouped together, so that they do not have to
be uniquely specified within the file. This will make it easier to create the atoms and this means
they are more likely to be used.

/**
 * @file: file_name
 * @group: <group_name> This defines the group that the atoms will default to.
 * @timeline: <timeline name> This defines the default timeline that is used in the state machine.
 * @author: <name of the author>
 * @date: <date that the file was updated>
 */

This is a simple grouping that will belong to the top of the file. This block should only exist the
once and should not be repeated.

API
===

The API atoms are there to help annotate the code functions to allow for documentation to be built
with documentation that is properly embedded within the source code.

The API splits into two parts the data definitions and the function definitions.  The function definitions
are easiest to handle:

/**
 * @api:		<function name>
 * @brief:		<the brief description of the function - one line>
 * @action:		<What this function actually does>
 * @group:		<the api group that it belongs to>
 * @parameter:	<name>	<description>	One of the parameters, If any.
 * @returns:	<value> <reason>		One of the return values, If any.
 * @ignore:		This stops all collection of data from the header block.
 */

The parameters will be matched with the ones that are found in the function header that follows. An error
will be generated if they do not match.

If there is a structure following the block with the @message in it then this is used as the definition
of the message format. If a function is defined after the @message then the parameters to this message
is used to define the message contents.


Data Definitions
================

Data types definitions are a little more variable.

/**
 * @type:	name
 */
typedef struct
{
	unsigned int	fred;	/** this field does stuff */
	unsigned char	harry;	/** this other field does other stuff */
}
	
/**
 * @defines: name
 * @desc:
 * description of the define group the follows.
 */
#define	SOME_STUFF	(fddddffdf)	/** This line will describe the stuff */
#define	SOME_STUFF	(fddddffdf)	/** This line will describe the stuff */
#define	SOME_STUFF	(fddddffdf)	/** This line will describe the stuff */

All the above defines will be in the same block in the diagram and will be in the same table.

All the definitions can be part of a group and grouped together as apart of the API, so can
be referenced in the same way.

/**
 * @record:	<message_name>
 * @field:	<type>	name
 * @field:	<type>	name
 */

The record is a special typedef for data structures that are built in data and are not structures.
These are more data packets and the like so that the structure of the message can be built from them.

Types and defines must be referenced slightly differently. The URI should be something along the 
lines of.

    [model:/<group>/data_defs/<names>]

So it works like the rest and can be referenced in the same way.


State Machines
==============

The State machine has the basic layout as this.

/**
 * @state: state_1
 * @next: state_4
 * @trigger: trigger5;
 * @triggers: $STATE_ONE.trigger2
 * @triggers: $STATE_ONE.trigger4
 */

or

/**
 * @state: state_1
 * @next: state_4
 * @condition: Some text to describe the condition.
 * @triggers: $STATE_ONE.trigger2
 * @triggers: $STATE_ONE.trigger4
 */


Sequence Diagrams
=================

For sequence diagrams the following is a summary of the ways of defining nodes.
The messages are the connectors for the sequences and they can be grouped into functions.
The function is treated as a whole unit and will always complete in the order that it is specified in.

Obviously, all the node types can be specified differently outside of the function, but their order
will not be guaranteed as they are when specified within a function.

/**
 * @function: play_media
 */
void	play_media()
{
	/**
	 * @send: REQUEST_TRACK_DATA
	 * @to: media_source
	 */

	/**
	 * @waitfor: SEND_TRACK_DATA
	 */

	/* handle playing the track data */

	/* @responds: ACK
	 *
	 * we have finished the playing of the data, acknowledge to the requester that it has
	 * been done.
	 */
}




