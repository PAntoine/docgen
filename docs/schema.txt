Structural Atoms
================

The atoms and timelines specified within a file can be grouped together, so that they do not have to
be uniquely specified within the file. This will make it easier to create the atoms and this means
they are more likely to be used.

/**
 * @file: file_name
 * @group: <group_name> This defines the group that the atoms will default to.
 * @timeline: <timeline name> This defines the default timeline that is used in the state machine.
 * @author: <name of the author>
 * @date: <date that the file was updated>
 */

This is a simple grouping that will belong to the top of the file. This block should only exist the
once and should not be repeated.

also can add to this group the ones required for the man pages. The only one of note is the @option
as this will be used to build the options. The rest will be built from the text.


API
===

The API atoms are there to help annotate the code functions to allow for documentation to be built
with documentation that is properly embedded within the source code.

The API splits into two parts the data definitions and the function definitions.  The function definitions
are easiest to handle:

/**
 * @api:		<function name>
 * @brief:		<the brief description of the function - one line>
 * @action:		<What this function actually does>
 * @group:		<the api group that it belongs to>
 * @parameter:	<name>	<description>	One of the parameters, If any.
 * @returns:	<value> <reason>		One of the return values, If any.
 * @ignore:		This stops all collection of data from the header block.
 */

The parameters will be matched with the ones that are found in the function header that follows. An error
will be generated if they do not match.

If there is a structure following the block with the @message in it then this is used as the definition
of the message format. If a function is defined after the @message then the parameters to this message
is used to define the message contents.


Data Definitions
================

Data types definitions are a little more variable.

/**
 * @type:	name
 */
typedef struct
{
	unsigned int	fred;	/** this field does stuff */
	unsigned char	harry;	/** this other field does other stuff */

	struct name		name;

	struct name		tag_name	/** this file */
	{
		type	name;			/** this is a thing */
	} name;
} name;
	
/**
 * @defines: name
 * @desc:
 * description of the define group the follows.
 */
#define	SOME_STUFF	(fddddffdf)	/** This line will describe the stuff */
#define	SOME_STUFF	(fddddffdf)	/** This line will describe the stuff */
#define	SOME_STUFF	(fddddffdf)	/** This line will describe the stuff */

All the above defines will be in the same block in the diagram and will be in the same table.

All the definitions can be part of a group and grouped together as apart of the API, so can
be referenced in the same way.

/**
 * @record:	<message_name>
 * @field:	<type>	name
 * @field:	<type>	name
 */

The record is a special typedef for data structures that are built in data and are not structures.
These are more data packets and the like so that the structure of the message can be built from them.

Types and defines must be referenced slightly differently. The URI should be something along the 
lines of.

    [model:/<group>/data_defs/<names>]

So it works like the rest and can be referenced in the same way.


State Machines
==============

The State machine has the basic layout as this.

/**
 * @state: state_1
 * @next: state_4
 * @trigger: trigger5;
 * @triggers: $STATE_ONE.trigger2
 * @triggers: $STATE_ONE.trigger4
 */

or

/**
 * @state: state_1
 * @next: state_4
 * @condition: Some text to describe the condition.
 * @triggers: $STATE_ONE.trigger2
 * @triggers: $STATE_ONE.trigger4
 */


Sequence Diagrams
=================

For sequence diagrams the following is a summary of the ways of defining nodes.
The messages are the connectors for the sequences and they can be grouped into functions.
The function is treated as a whole unit and will always complete in the order that it is specified in.

Obviously, all the node types can be specified differently outside of the function, but their order
will not be guaranteed as they are when specified within a function.

/**
 * @function: play_media
 */
void	play_media()
{
	/**
	 * @send: REQUEST_TRACK_DATA
	 * @to: media_source
	 */

	/**
	 * @waitfor: SEND_TRACK_DATA
	 */

	/* handle playing the track data */

	/* @responds: ACK
	 *
	 * we have finished the playing of the data, acknowledge to the requester that it has
	 * been done.
	 */
}

Text Formats
============

A couple of issues need to be removed. The formatting of text.

1. Borders.

if you have the following:

 /**--------------------------------------------------*
  * @desc: dfgfgfg fg fdg fdg dfg dfg dfg dg dg dsfg 
  *        dffd sfdsf sdfsd fds fdf df dsf 
  *        ddsfsd fdsf df dsf dsf dsf dsf sdf sdf
  *---------------------------------------------------*/

We do not want either the whitespace between '*' and the text and the '-''s for the last line.

So, if we have a continuation of comment function, that checks for that after any whitespace
at the start of aline, then we can remove the whitespace.

Also, in the same case if a character follows the continuation then it will be removed. This also
counts for ones that do not end in the comment end char.

2. ASCII art, formatted text.

As the above would destroy that, we need to reinstate it. As the ':' is seemingly more and more
redundant, and will be remove from the atom check. If following is found, we can treat anything
after the ':' as formatted text and the white space will not be removed.

 /**--------------------------------------------------*
  * @desc :          +-----------------------+
  *       :          |  some box diagram     |
  *       :          +-----------------------+
  *---------------------------------------------------*/

Also, if the ':' is found then the whole line (with the EOL's removed) will be used without parsing.
Obviously with the chaining of '@' possible, this will break that.

These lines will have to be marked as formatted and would need to be reinstated on the other side.

3. Normal comments.

These should be skipped as they are not at the moment and are showing up in some of the larger
data structures.

4. White Space

Some the data structures have a lot of white space that needs removing. It should.

Options (application)
=====================

Trying to get:

app <option_a> <option_b>
app <option_b> <option_c> <option_d>
...




/**------------------------------------*
 * @option:		<option_name>
 * @name:		d
 * @parameter:	name	values
 * @description:
 *  fgdfgfgfgfsdgfsgfg fgf dgfd gfd gfd
 *--------------------------------------*/
