/*--------------------------------------------------------------------------------*
 * Name: Parser Look-up tree
 * Desc: function and data structures to speed up a specific string search
 *
 *         **** DO NOT AMEND THIS CODE - IT IS AUTO_GENERATED ****
 *
 * Code and table produced by:
 *            build_graph 
 *            version 0.8
 *
 *  written by Peter Antoine. 
 *
 *   **** This code can be used however you like, no claims whatsoever are ****
 *   **** placed on the auto-generated code or data, or on the code that   ****
 *   **** uses the that code or data.                                      ****
 *   **** Or, to paraphrase "Fill your boots".                             ****
 *--------------------------------------------------------------------------------*/

#include "atoms.h"

ATOMS_STRING_TABLE	atoms_table[53] = {
		{"action",6},
		{"activation",10},
		{"after",5},
		{"api",3},
		{"application",11},
		{"author",6},
		{"brief",5},
		{"call",4},
		{"command",7},
		{"condition",9},
		{"constants",9},
		{"copyright",9},
		{"description",11},
		{"desc",4},
		{"date",4},
		{"end_constants",13},
		{"end_sample",10},
		{"entry",5},
		{"examples",8},
		{"file",4},
		{"function",8},
		{"group",5},
		{"ignore",6},
		{"licence",7},
		{"message",7},
		{"multiple",8},
		{"name",4},
		{"next",4},
		{"option",6},
		{"parameter",9},
		{"parameters",10},
		{"prototype",9},
		{"record",6},
		{"repeats",7},
		{"required",8},
		{"responds",8},
		{"returns",7},
		{"sample",6},
		{"section",7},
		{"see_also",8},
		{"send",4},
		{"state",5},
		{"subsection",10},
		{"synopsis",8},
		{"tag",3},
		{"timeline",8},
		{"to",2},
		{"trigger",7},
		{"triggers",8},
		{"type",4},
		{"value",5},
		{"waitfor",7},
		{"zzzz",4}
};

static signed char	symbol_table[256] = 
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x15,
	 0x00,0x01,0x0F,0x02,0x11,0x09,0x08,0x14,0x0E,0x04,0x00,0x00,0x0C,0x10,0x06,0x05,
	 0x0B,0x17,0x0A,0x12,0x03,0x0D,0x07,0x18,0x16,0x13,0x19,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

typedef struct
{	unsigned char	mask;
	unsigned char	table;
} LOOKUP_TABLE;

static LOOKUP_TABLE	state_table[43] = {
	{ 0, 0},{ 1, 1},{ 2, 1},{ 3, 1},{ 4, 1},{ 5, 2},{ 6, 2},{ 7, 3},{ 8, 1},{ 9, 1},{10, 2},{11, 2},{12, 0},{13, 2},{14, 1},{15, 2},
	{16, 0},{17, 3},{18, 3},{19, 2},{ 9, 3},{20, 4},{21, 1},{22, 5},{23, 1},{24, 4},{25, 3},{24, 5},{21, 3},{12, 0},{26, 4},{24, 6},
	{27, 5},{28, 7},{29, 8},{30, 6},{ 2, 4},{31, 1},{31, 2},{24, 9},{21, 5},{12, 0},{26, 6}};

static unsigned int mask_table[32] = {
	0x01179ffe,0x00000009,0x00000010,0x000000a0,0x00002904,0x00000810,0x00000022,0x00010840,
	0x00060000,0x00000202,0x00040000,0x00000004,0x00000000,0x00000401,0x00400040,0x00020008,
	0x00200000,0x00040004,0x00002010,0x00002200,0x00000402,0x00000400,0x00000002,0x00010000,
	0x00000200,0x00000008,0x00040001,0x0084080c,0x0008220a,0x00000244,0x00080432,0x00100000};

static unsigned char table[10][25] = {
	{0x00,0x04,0x06,0x23,0xe9,0xe3,0x14,0xcd,0x12,0x0e,0x1f,0x15,0xe8,0x00,0x00,0xf9,0x13,0x09,0x21,0x00,0xea,0x11,0x00,0x00,0xcc},
	{0xcb,0xf1,0x01,0x02,0x03,0xff,0x0f,0xfe,0xfd,0x0a,0x17,0x05,0x00,0xfa,0x00,0x00,0x19,0xf6,0xf5,0x00,0x26,0x00,0xed,0x00,0x00},
	{0xf2,0xf8,0x0d,0xee,0xfc,0x07,0x00,0x00,0x00,0xe7,0xf3,0xfb,0x00,0xe6,0x00,0x00,0x00,0x10,0x0b,0x00,0x27,0x00,0x00,0x00,0x00},
	{0x00,0xe5,0xf0,0x1b,0xec,0x00,0x08,0x00,0x00,0xe4,0x1e,0xf4,0x00,0xeb,0x00,0x00,0xf7,0x00,0xef,0x00,0x00,0x00,0x00,0x00,0x00},
	{0xe2,0x16,0x00,0x00,0x25,0x00,0x00,0x00,0x00,0x1a,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe1,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x18,0xdf,0xdb,0x00,0x00,0x00,0x00,0x00,0x1c,0x2a,0xde,0x00,0x00,0x00,0x00,0x00,0x00,0xdc,0x00,0x00,0x00,0x00,0xdd,0x00},
	{0xd0,0xd3,0x00,0x00,0xd2,0xd1,0x00,0x00,0x00,0x20,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xcf,0xce,0x00,0x00,0x00,0x00,0x00},
	{0x00,0xda,0x00,0xd6,0x00,0x00,0x00,0x00,0x00,0x22,0x00,0x00,0x00,0xd5,0x00,0x00,0x00,0x00,0x00,0xd4,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0xd9,0x00,0x00,0x00,0xd7,0x00,0x00,0xd8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}};

unsigned int atoms_get_length(int word)
{
	return atoms_table[word].length;
}

int	atoms_check_word(unsigned char* word)
{
	signed char		line = 0;
	unsigned int	symbol = 0;
	unsigned int	count = 0;
	unsigned int	letter = 0;
	unsigned int	symbol_bit;

	do
	{
		symbol = symbol_table[word[letter]];
		symbol_bit = (0x1 << (symbol & 0x1F));

		if ((mask_table[state_table[line].mask] & symbol_bit) == 0)
		{
			/* bad symbol for line */
			line = 0;
		}
		else
		{
			line = (signed char) table[state_table[line].table][symbol];
		}
		letter++;

	}
	while (line > 0);

	symbol_bit = (0x1 << (symbol_table[word[letter]] & 0x1F));

	if (line < 0)
		line = (0-line) - 1;
	else if (((mask_table[state_table[line].mask] & symbol_bit) != 0) && ((line = (signed char) table[state_table[line].table][symbol_table[0]]) < 0))
		line = (0-line) - 1;
	else
		line = -1;
	if (line >= 0)
	{
		for (count=letter;count < atoms_table[line].length;count++)
		{
			if (word[count] != atoms_table[line].name[count])
			{
				line = -1;
				break;
			}
		}
	}
	return line;
}
