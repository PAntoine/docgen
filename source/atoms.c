/*--------------------------------------------------------------------------------*
 * Name: Parser Look-up tree
 * Desc: function and data structures to speed up a specific string search
 *
 *         **** DO NOT AMEND THIS CODE - IT IS AUTO_GENERATED ****
 *
 * Code and table produced by:
 *            build_graph 
 *            version 0.8
 *
 *  written by Peter Antoine. 
 *
 *   **** This code can be used however you like, no claims whatsoever are ****
 *   **** placed on the auto-generated code or data, or on the code that   ****
 *   **** uses the that code or data.                                      ****
 *   **** Or, to paraphrase "Fill your boots".                             ****
 *--------------------------------------------------------------------------------*/

#include "atoms.h"

ATOMS_STRING_TABLE	atoms_table[17] = {
		{"activation",10},
		{"after",5},
		{"call",4},
		{"condition",9},
		{"message",7},
		{"next",4},
		{"parameter",9},
		{"repeats",7},
		{"responds",8},
		{"send",4},
		{"state",5},
		{"timeline",8},
		{"to",2},
		{"trigger",7},
		{"triggers",8},
		{"waitfor",7},
		{"function",8}
};

static signed char	symbol_table[256] = 
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x01,0x00,0x02,0x0C,0x09,0x08,0x0F,0x00,0x04,0x00,0x00,0x0B,0x0D,0x07,0x06,
	 0x11,0x00,0x0A,0x0E,0x03,0x13,0x05,0x12,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

typedef struct
{	unsigned char	mask;
	unsigned char	table;
} LOOKUP_TABLE;

static LOOKUP_TABLE	state_table[14] = {
	{ 0, 0},{ 1, 1},{ 2, 1},{ 3, 0},{ 4, 1},{ 5, 1},{ 6, 2},{ 7, 0},{ 8, 0},{ 8, 1},{ 3, 2},{ 9, 1},{10, 0},{11, 2}};

static unsigned int mask_table[12] = {
	0x0006658e,0x00000104,0x00000042,0x00000200,0x00024000,0x00000208,0x00000450,0x00000010,
	0x00008000,0x00000400,0x00000000,0x00004001};

static unsigned char table[3][19] = {
	{0x00,0x01,0x02,0x06,0x08,0x00,0x00,0xfa,0xef,0x04,0x03,0x00,0x00,0xfb,0x05,0x09,0x00,0xf9,0xf0},
	{0x00,0xfd,0xff,0xf5,0x00,0x00,0xfc,0x00,0xfe,0xf6,0x0d,0x00,0x00,0x00,0xf7,0x0a,0x00,0xf8,0x00},
	{0xf2,0x00,0x00,0x00,0xf4,0x00,0xf3,0x00,0x00,0x0b,0x07,0x00,0x00,0x00,0xf1,0x00,0x00,0x00,0x00}};

unsigned int atoms_get_length(int word)
{
	return atoms_table[word].length;
}

int	atoms_check_word(unsigned char* word)
{
	signed char		line = 0;
	unsigned int	symbol = 0;
	unsigned int	count = 0;
	unsigned int	letter = 0;
	unsigned int	symbol_bit;

	do
	{
		symbol = symbol_table[word[letter]];
		symbol_bit = (0x1 << (symbol & 0x1F));

		if ((mask_table[state_table[line].mask] & symbol_bit) == 0)
		{
			/* bad symbol for line */
			line = 0;
		}
		else
		{
			line = (signed char) table[state_table[line].table][symbol];
		}
		letter++;

	}
	while (line > 0);

	symbol_bit = (0x1 << (symbol_table[word[letter]] & 0x1F));

	if (line < 0)
		line = (0-line) - 1;
	else if (((mask_table[state_table[line].mask] & symbol_bit) != 0) && ((line = (signed char) table[state_table[line].table][symbol_table[0]]) < 0))
		line = (0-line) - 1;
	else
		line = -1;
	if (line >= 0)
	{
		for (count=letter;count < atoms_table[line].length;count++)
		{
			if (word[count] != atoms_table[line].name[count])
			{
				line = -1;
				break;
			}
		}
	}
	return line;
}
